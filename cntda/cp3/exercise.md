P1

假设 A 的端口号是1001，B 的端口号是 1002，S 的端口号是 1003.

A: 1001、1003

B: 1002、1003

C: 1003、1001

D: 1003、1002

E: 可以

F: 不可以

P2

略

P3

？

P4:

略

P5

不能，参见上一题答案。

P6

图 3-57 中并没有回复 ACK，所以会导致发送方一直重发。

P7

不需要有需要，只需要确认是哪个分组收到就行。？

P8

略

P9

略

P10

略

P11

如果自转换的状态删除，那么将不能处理分组发生错误，或者序号乱序的问题，也就不能重发，最终deadlock。

P12

？

P13

?

P15

2451 的窗口长度

P16

可以增加信道利用率，但是如果这中间出现丢包，那么并不能够保证会被重传。

P17

略

P21 略

P22

P24

A：true

B：true

C：true

D: true

P25

A:因为在 UDP 中，不用对发送的报文进行分组，应用程序给多少数据，都是一次发送的。

B:因为 UDP 不用像 TCP 那样在发送数据之前需要通过三次握手建立连接，UDP 是不用建立连接，所以发送数据可以更随意。同时，UDP 没有 flow control 和 congestion control，所以不存在时延。

P26

a 总共有 2^32 个序列号，由于序列号是根据发送的数据来给定的，因此能够发送的文件大小是 2^32 bit.

b: 略

P27

P29

A: 为了防止 SYN flood attack，当服务器收到一个 SYN 报文段时，并不马上分配资源，而是生成一个初始的TCP 序列号，该序列号是 SYN 报文段的源和目的地 IP 地址、端口号以及仅有服务器知道的秘密数生成的一个序列号，这个序列号也被称为 cookie。重要的是，服务器并不记忆改 cookie 或者任何对应于 SYN 的其它状态信息。

如果客户是合法的，那么它会回复一个 ACK 报文段，当服务器收到该报文段时候，验证一下就可以判断之前客户是否发送过 SYN 报文段，进而建立连接。

不能，因为在生成 cookie 的时候，服务端可以添加一个 timestamp，这样只有在固定的时间内，该 cookie 才是有效的，超过该时间，回复的 ACK 也无效。

P30

A: 由于超时的时间是固定的，如果增加路由器的有限缓存，那么很多分包还没有丢失，超时事件就发生了，这个时候，发送方不得不对该分组进行重传，导致吞吐量减少。

B：是可以增加吞吐量的，只要我们将超时事件设置的足够长，就可以尽量减少重传，但是会导致另外一个问题，就是排队时延会很长。

P33

因为重传报文段会导致 SampleRTT 计算失误，比如我们发送了一个报文段 P1, 超时后，进行重传，发送相同的报文段 P2，在不久后，收到了对 P1 的 回复 ACK，这个时候我们可能会误以为是 P2 的 ACK，导致计算 SampleRTT 错误。

P34

由于 LastByteRecv 的 ACK 被 sender 收到，那么就有 SendBase - 1 = LastByteRecv，如果 LastByteRecv 的 回复确认，sender 还没有收到，那么就有如下不等式：

SendBase - 1 <= LastByteRecv

P35

y - 1 <= LastByteRecv

P36

快速重传的目的，是在某个可能丢失的分包后的2个包已经到了接收方，这个时候，就基本能够判断之前的包丢失了，所以执行快速重传。

P38

发送方的速率大约等于 (cwnd / RTT)

P45
