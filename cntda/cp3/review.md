R1:

a.我们将这个协议取名为 Simple Transfer Protocol，它从应用层拿到数据，和IP地址、端口号，将数据拆分成不同的 thunks，然后给每一个 thunk 添加一个 header，将端口号放到 header 中，然后将 IP 地址和封装好的 thunks 交给网络层，网络层将 thunks 传递到目的主机的网络层，然后递交给目的主机的运输层，目的主机的运输层从thunks 中提取出端口号，并且组装成完整数据，根据目的端口号，交给相应的进程。

b.应用层就需要将源IP，源 port 和目的 ip 目的 port 都给运输层，然后运输层的header 包含 两个 port，然后将 两个 ip 及 thunks 传给给网络层，其它基本都一样。

c. 不是，Translation layer 在端系统中。

R2:

a. 在这个过程中，家庭成员之一扮演的就是运输层的工作，在发件方，家庭代表成员将发件人的姓名写在了信件的顶部，然后塞进信封，交给邮递员，邮递员运输改信件到目的家庭，目的家庭的代表成员打开信封，找到收件人，然后将信件交到收件人手里。

b.不需要

R3:

source port is y and destination port is x。

R4:

应为 UDP 不需要建立连接，因此传输效率会更高。同时 TCP 拥有流量控制和拥塞控制，而 UDP 没有，所以 UDP 可以以更快的速率传输。

R5:

因为大部分的防火墙都会阻碍 UDP 流量。

R6:

可以，需要应用程序自己实现可靠的数据传输。

R7:

是的，在报文中有 source id 和 port。

R8:

不是相同的 Socket，都是 80 端口号，不同的 Socket 通过 源 ip，port 和 目的 ip、port 来识别。

R9:

因为在 rdt 2 中，ACK 和 NAK 可能被损坏，通过引入序号，这样 receiver 在回复 ACK 时候，就可以明确的是说是确认序号 0 还是序号 1，在 sender 端，sender 本来是需要收到ACK 1 的结果收到了 ACK 0，那么就需要重传，说明 ACK 被损坏了。

同时在接收方，也为了确认data是重传的还是新内容。

R10:

是为了解决包丢失的问题，分两种情况：有可能是发送的包丢失，有可能是回复确认的包丢失，通过引入定时器，当时间到了，还没收到回复包，就重传。

R11:

仍然是必须的，只是 timeinterval 可以是一个静态的值，不用动态计算了，只用比 rtt 大一点就 OK 了。

R12:

A: 发送 5 个分组，在 5 个分组任意一个到达目的地之前，毁掉第一个分组，当 2~5 分组到达目的地时，并没有发送回复的 ACK，在超时后，重新发送了 1~5 分组。

B：如果只是毁掉了第一个分组的确认，那么由于 GBN 是采用累积确认的机制，当第 2~5 分组的确认到达发送方时，发送方的 window 也会向右移动 5 个单位。

C：第六个分组发送不出去，因为不能超过 window size 的限制，这样才能有效的进行 flow control 和 congestion control。

R13:

A: 如果 0 号分组被损坏，1~4 号分组依然会回复确认，并且接收方的窗口右移，但是当发送到收到1~4号的确认后，并不马上移动窗口，等到 0 号分包超时后，再次发送 0 号分包，等到确认后，发送方窗口右移 5 个单位。

B: 同上。

C: 同 R12 C。

R14:

A: FALSE

B: FALSE

C: TRUE (FLOW CONTROL)

D: FALSE

E: TRUE

F: FALSE

G: FALSE

R15:

A: 20 btye

B: 90

R: 16

总共发送了三个报文段。

第一个报文段： 序号和确认号分别是43、80

第二个报文段：80、44

第三个报文段：44、81
